import java.util.Scanner;

public class Main {

    public static void main(String[] args) {
        // измененный код.
    }

}


/*
Здесь я пока буду записывать всякую информацию про java, пока не заведу нормальную тетрадь

ООП
любой объект может обладать двумя основными характеристиками - состояние и поведение
состояние - некоторые данные, которые хранит объект.
поведение - действия которые может совершать объект.

для хранения состояния применяются поля или переменные класса
для определения поведения объекта применяются методы

поле - переменная уровня класса, пока что этого достаточно знать, в будущем о полях будет больше информации
метод - поведение описываемой сущности, именно в методах мы описываем логику обработки данных

конструктор - специальный блок кода, инициализирующий создание объекта определенного класса.
синтаксически конструктор похож на метод, но у него нет возвращаемого значения (ни void, и никакого другого)
так же имя конструктора совпадает с именем самого класса, и тоже начинается с прописной буквы

в целом, в конструкторе можно описать почти любую логику, но обычно они применяются для инициализации полей,
само собой это помимо главной функции конструктора - создания объекта.




Рекурсия - метод вызывает сам себя
с рекурсией у меня не задалось, а именно - с решением задач.

Перегрузка методов - механизм в java, а так же в ряде других ЯП, которая заключается в реализации методов с одинаковыми
названиями, но разными параметрами, и соответственно с разной реализацией.
в общем, это когда в классе есть ряд методов, они имеют одно и то же имя, но отличаются параметрами
и содержимым.

когда мы вызываем такой метод, то в зависимости от типа и количества передаваемых аргументов,
система сама выбирает подходящую версию метода, одного из.
на перегрузку метода влияет количество и типы параметров. т.е. если я создаю несколько одноименных методов
то они должны обязательно отличаться количеством и/или типом параметров. если сделать несколько одинаковых методов
и вместо void прописать разные типы данных то это не поможет, одноименные методы должны отличаться параметрами.

сигнатура метода - это имя метода и его параметры, модификаторы и тип возвращаемого значения не входят сюда.


объявление переменной и выделение памяти под объект - это две независимые вещи
объявление переменной - мы выделяем место в памяти, в котором потом будет ссылка на объект, или не будет, не важно

оператор new - выделяет в памяти место под объект, а так же создает сам объект



Переменные в  java делятся на два типа, по ссылке и по значению
по значению - значение непосредственно копируется в переменную
по ссылке - значение не копируется, в переменную копируется лишь ссылка на объект в памяти


тип данных boolean
false, true,
оператор сравнения, любой из шести ( < >, <= >=, == !== ) вернет false или true

boolean не конвертируется в другие типы данных, и наоборот, это значит что запись типа
boolean value = 10; вернет ошибку при компиляции



унарный оператор ++ или --
имеет значение, стоит он перед переменной или после
префиксная форма -  ++а, оператор вернет новое значение,
постфиксная форма -  а++ оператор вернет старое значение

тут важно понимать один нюанс - есть разница в том что возвращает оператор, и то что сама переменная изменяется
неважно какое значение возвращает оператор, переменная все равно изменяется, это хорошо видно в цикле for().
то значение которое возвращает оператор, это одно, а значение в самой переменной это другое.

 */